## UI 相关



###UIView与CALayer

```
UIView：负责处理触摸等事件，参与响应链
CALayer（需要加强学习）：内容展示和动画操作，layer 不相应事件，可以通过 View 响应事件来控制 layer 的属性变化
```

###UI卡顿掉帧原因

```
iOS 设备的硬件时钟会发出 Vsync（垂直同步信号），然后 App 的 CPU 会去计算屏幕要显示的内容，之后将计算好的内容提交到 GPU 去渲染。GPU 将渲染结果提交到帧缓冲区，等到下一个 VSync 到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由 CPU 和 GPU 共同决定的。
一般来说，页面滑动流畅是 60 fps，也就是 1 s 有 60 帧更新，即每隔 16.7 ms 就要产生一帧画面，而如果 CPU 和 GPU 加起来的处理时间超过了 16.7 ms，就会造成掉帧甚至卡顿。
```

## 数据逻辑

## 数据结构

### 数组和字符串

数组和字符串是最基本的数据结构，在很多编程语言中都有着十分相似的性质，而围绕着它们的算法面试题也是最多的。

很多时候，在分析字符串相关面试题的过程中，我们往往要针对字符串当中的每一个字符进行分析和处理，甚至有时候我们得先把给定的字符串转换成字符数组之后再进行分析和处理

**数组的优缺点**

```
优点：
	- 构建非常简单
	- 能在 O(1) 的时间里根据数组的下标（index）查询某个元素

缺点：
	- 构建时必须分配一段连续的空间
	- 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）
	- 删除和添加某个元素时，同样需要耗费 O(n) 的时间
```



### 链表（LinkedList）

单链表：链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。

双链表：与单链表不同的是，双链表的每个结点中都含有两个引用字段。

**链表的优缺点**

```
优点：
	- 链表能灵活地分配内存空间；
	- 能在 O(1) 时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。

缺点：
	- 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；
	- 查询第 k 个元素需要 O(k) 时间。
```

**应用场景**：如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。

链表是实现很多复杂数据结构的基础，经典解法如下

**1. 利用快慢指针（有时候需要用到三个指针）**

典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。

**2. 构建一个虚假的链表头**

一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

**建议：**在解决链表的题目时，可以在纸上或者白板上画出节点之间的相互关系，然后画出修改的方法，既可以帮助你分析问题，又可以在面试的时候，帮助面试官清楚地看到你的思路。

### 栈（Stack）

**特点**：栈的最大特点就是后进先出（LIFO），对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。

**实现**：利用一个单链表来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在 O(1) 的时间内完成。

**应用场景**：在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。

如果打算用一个数组外加一个指针来实现相似的效果，那么，一旦数组的长度发生了改变，哪怕只是在最后添加一个新的元素，时间复杂度都不再是 O(1)，而且，空间复杂度也得不到优化。

### 队列（Queue）

**特点**：和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。

**实现**：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。

**应用场景**：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。

### 双端队列（Deque）

**特点**：双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。

**实现**：与队列相似，我们可以利用一个双链表实现双端队列。

**应用场景**：双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目里都有运用。

###树（Tree）

在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。

对于一些特殊的树，例如红黑树（Red-Black Tree）、自平衡二叉搜索树（AVL Tree），一般在面试中不会被问到，除非你所涉及的研究领域跟它们相关或者你十分感兴趣，否则不需要特别着重准备。

关于树的考题，无非就是要考查树的遍历以及序列化（serialization)。

**树的遍历**

**1. 前序遍历（Preorder Traversal）**

**方法**：先访问根节点，然后访问左子树，最后访问右子树。在访问左、右子树的时候，同样，先访问子树的根节点，再访问子树根节点的左子树和右子树，这是一个不断递归的过程。

**应用场景**：运用最多的场合包括在树里进行搜索以及创建一棵新的树。

**2. 中序遍历（Inorder Traversal）**

**方法**：先访问左子树，然后访问根节点，最后访问右子树，在访问左、右子树的时候，同样，先访问子树的左边，再访问子树的根节点，最后再访问子树的右边。

**应用场景**：最常见的是二叉搜素树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。

 **3. 后序遍历（Postorder Traversal）**

**方法**：先访问左子树，然后访问右子树，最后访问根节点。

**应用场景**：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。

 **注意**：

- 掌握好这三种遍历的递归写法和非递归写法是非常重要的，懂得分析各种写法的时间复杂度和空间复杂度同样重要。
- 无论是前端工程师，还是后端工程师，在准备面试的时候，树这个数据结构都是最应该花时间学习的，既能证明你对递归有很好的认识，又能帮助你学习图论（关于图论，我们将在下一节课一起讨论）。树的许多性质都是面试的热门考点，尤其是二叉搜索树（BST）。

**建议**：练习一道经典的 LeetCode 第 250 题，在一棵二叉树里，统计有多少棵子树，要求子树里面的元素拥有相同的数字。

### 优先队列（Priority Queue）

**特点**：能保证每次取出的元素都是队列中优先级别最高的。优先级别可以是自定义的，例如，数据的数值越大，优先级越高；或者数据的数值越小，优先级越高。优先级别甚至可以通过各种复杂的计算得到。

**应用场景**：

从一堆杂乱无章的数据当中按照一定的顺序（或者优先级）逐步地筛选出部分乃至全部的数据。

**举例**：任意一个数组，找出前 k 大的数。

 **解法 1**：先对这个数组进行排序，然后依次输出前 k 大的数，复杂度将会是 O(nlogn)，其中，n 是数组的元素个数。这是一种直接的办法。

 **解法 2**：使用优先队列，复杂度优化成 O(k + nlogk)。

当数据量很大（即 n 很大），而 k 相对较小的时候，显然，利用优先队列能有效地降低算法复杂度。因为要找出前 k 大的数，并不需要对所有的数进行排序。



## 底层知识



## 网络



### 网络七层协议（Open System Interconnection，OSI）

OSI是一个开放性的通信系统互连参考模型，它是一个定义得非常好的协议规范。OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 [应用层](https://baike.baidu.com/item/应用层/4329788) 6 [表示层](https://baike.baidu.com/item/表示层/4329716) 5 会话层 4 [传输层](https://baike.baidu.com/item/传输层/4329536) 3 网络层 2 [数据链路层](https://baike.baidu.com/item/数据链路层/4329290) 1 [物理层](https://baike.baidu.com/item/物理层/4329158) ；其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端的[数据流](https://baike.baidu.com/item/数据流/3002243)。

- 好处：

  ```
  1.使人们容易探讨和理解协议的许多细节。
  2.在各层间标准化接口，允许不同的产品只提供各层功能的一部分，（如路由器在一到三层），或者只提供协议功能的一部分。（如Win95中的Microsoft TCP/IP）
  3. 创建更好集成的环境。
  4. 减少复杂性，允许更容易编程改变或快速评估。
  5. 用各层的headers和trailers排错。
  6.较低的层为较高的层提供服务。
  7. 把复杂的网络划分成为更容易管理的层。
  ```

  

- HTTP 协议

  ```
  是一种浏览器和万维网服务器之间通信的规则，基于  TCP 的 应用层 协议
  ```

  

##算法



##性能优化